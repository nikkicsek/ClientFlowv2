Got it—thanks for the snapshot. You’re running into a classic “session → DB identity” mismatch: the web session exists, but your API/debug routes try to load a DB user/team member and bail out when they don’t find one. Below is a drop‑in fix + a tight test plan so you can keep moving.

What to implement
1) A single resolver used by all /api/* and /debug/* routes
Express middleware (TypeScript/JS)
// middleware/identity.ts
import type { Request, Response, NextFunction } from 'express';
import { prisma } from '../prisma'; // or your db client

export type Identity = {
  userId: string;
  email: string;
  teamMemberId: string | null;
};

export async function resolveSessionIdentity(req: Request, res: Response, next: NextFunction) {
  // 1) Require session
  const sessUser = (req.session as any)?.user; // { id, email }
  if (!sessUser?.id || !sessUser?.email) {
    return res.status(401).json({ error: 'No session' });
  }

  const userId = String(sessUser.id);
  const email = String(sessUser.email).toLowerCase();

  // 2) Upsert users row
  await prisma.users.upsert({
    where: { id: userId },
    create: { id: userId, email },
    update: { email },
  });

  // 3) Link/find team_members by user_id OR email
  let teamMember = await prisma.team_members.findFirst({
    where: { OR: [{ user_id: userId }, { email }] },
    select: { id: true, user_id: true, email: true },
  });

  // 4) If none, create/link
  if (!teamMember) {
    teamMember = await prisma.team_members.create({
      data: { user_id: userId, email },
      select: { id: true, user_id: true, email: true },
    });
  } else if (!teamMember.user_id) {
    // Repair: backfill user_id if missing
    await prisma.team_members.update({
      where: { id: teamMember.id },
      data: { user_id: userId, email },
    });
  }

  // 5) Attach identity to request
  (req as any).identity = {
    userId,
    email,
    teamMemberId: teamMember?.id ?? null,
  } as Identity;

  return next();
}


Key behavior: If there is a session, we never return “User not found”. We create/repair the DB mapping on the fly.

Router order (very important)
// server.ts
app.use(sessionMiddleware);          // must come first
app.use('/api', resolveSessionIdentity, apiRouter);
app.use('/debug', resolveSessionIdentity, debugRouter);
app.use('/', webRouter);

2) Normalize “my tasks” queries to accept any identifier
// lib/tasks.ts
import { prisma } from '../prisma';
import type { Identity } from '../middleware/identity';

export async function getMyTasks(identity: Identity) {
  const { teamMemberId, userId, email } = identity;

  // Prefer teamMemberId, fallback to userId, then email
  if (teamMemberId) {
    return prisma.tasks.findMany({ where: { team_member_id: teamMemberId }, orderBy: { created_at: 'desc' } });
  }
  // If your tasks table is keyed by user_id or email, support those fallbacks:
  const tasksByUser = await prisma.tasks.findMany({ where: { user_id: userId }, orderBy: { created_at: 'desc' } });
  if (tasksByUser.length) return tasksByUser;

  return prisma.tasks.findMany({ where: { assignee_email: email }, orderBy: { created_at: 'desc' } });
}

3) /debug endpoints (no ?as= needed, but still supported for impersonation)
// routes/debug.ts
import { Router } from 'express';
import type { Request, Response } from 'express';
import { getMyTasks } from '../lib/tasks';

export const debugRouter = Router();

// Probe endpoint
debugRouter.get('/auth/whoami', async (req: Request, res: Response) => {
  const sessUser = (req.session as any)?.user ?? null;
  const identity = (req as any).identity ?? null;

  return res.json({
    hasSession: Boolean(sessUser),
    sessionUser: sessUser ? { id: String(sessUser.id), email: String(sessUser.email) } : null,
    dbUser: identity ? { id: identity.userId, email: identity.email } : null,
    teamMemberId: identity?.teamMemberId ?? null,
  });
});

// My tasks (optionally allow impersonation for admins)
debugRouter.get('/my-tasks', async (req: Request, res: Response) => {
  const identity = (req as any).identity;
  const asEmail = (req.query.as as string | undefined)?.toLowerCase();

  const effectiveIdentity = asEmail
    ? { ...identity, email: asEmail, teamMemberId: null } // bypass to test impersonation
    : identity;

  const tasks = await getMyTasks(effectiveIdentity);
  return res.json(tasks);
});

4) Database notes (Prisma schema or SQL)

Prisma (example)

model users {
  id    String @id
  email String @unique
  // created_at/updated_at...
}

model team_members {
  id      String  @id @default(uuid())
  user_id String?
  email   String  @unique
  // Index to quickly find by user_id OR email
  @@index([user_id])
}

model tasks {
  id             String  @id @default(uuid())
  team_member_id String?
  user_id        String?
  assignee_email String?
  title          String
  status         String   @default("open")
  created_at     DateTime @default(now())
  // helpful indexes
  @@index([team_member_id])
  @@index([user_id])
  @@index([assignee_email])
}


Raw SQL (if not using Prisma)

-- users
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT NOT NULL UNIQUE
);

-- team_members
CREATE TABLE IF NOT EXISTS team_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT,
  email TEXT NOT NULL UNIQUE
);
CREATE INDEX IF NOT EXISTS idx_team_members_user_id ON team_members(user_id);

-- tasks
CREATE TABLE IF NOT EXISTS tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  team_member_id UUID,
  user_id TEXT,
  assignee_email TEXT,
  title TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'open',
  created_at TIMESTAMP NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_tasks_team_member_id ON tasks(team_member_id);
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_assignee_email ON tasks(assignee_email);

Quick test plan (copy/paste ready)

Once you’ve mounted the middleware and routes as above:

# 1) Verify session (already works for you)
curl -s https://<your-host>/auth/status

# 2) Probe identity mapping (should be non-null after resolver runs)
curl -s https://<your-host>/debug/auth/whoami

# Expected shape:
# {
#   "hasSession": true,
#   "sessionUser": {"id":"45577581","email":"nikki@csekcreative.com"},
#   "dbUser": {"id":"45577581","email":"nikki@csekcreative.com"},
#   "teamMemberId": "5d398f53-..."  // not null
# }

# 3) Tasks without impersonation (NO ?as=)
curl -s https://<your-host>/debug/my-tasks

# 4) Optional impersonation (kept for admin/testing)
curl -s "https://<your-host>/debug/my-tasks?as=nikki@csekcreative.com"


If #2 shows hasSession:true but dbUser:null, the middleware isn’t running before /debug. Re-check route order.
If #3 returns an empty array but you expect tasks, confirm your tasks table uses one of: team_member_id, user_id, assignee_email. If it uses a different field, add a fallback in getMyTasks.

Why this fixes your exact error

You reported:
/auth/status → sessionExists:true
/debug/my-tasks → {"error":"User not found"}

With the resolver, any time a session exists we upsert the users row and create/repair the team_members link, so “User not found” can’t happen.

Keeping ?as= is fine for impersonation, but it’s no longer required just to make debug/API routes work.